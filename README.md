# A* алгоритм и сглаживанием с osqp

### Первая часть: Алгоритм A*
Я начал с A*, чтобы найти путь. Это алгоритм, который ищет кратчайший маршрут от старта `(0, 0)` до цели `(14, 14)`:

- **Как работает:** 
  - Считает `G` (число шагов от старта), `H` (примерное расстояние до цели) и `F = G + H` (общая оценка).
  - Идёт туда, где `F` меньше всего, проверяя соседей (вверх, вниз, влево, вправо), если там нет препятствий (`grid[nx, ny] == 0`).
- **Евклидово расстояние:** 
  - Это моя эвристика для `H`. Считаю его как `sqrt((x2 - x1)² + (y2 - y1)²)` через `np.linalg.norm`.
  - Например, от `(0, 0)` до `(14, 14)` — это примерно 19.8. Оно показывает, насколько точка близко к финишу "по прямой".
- **Реализация:** 
  - Использую `heapq` для очереди точек, беру точку с минимальным `F`, запоминаю путь в `came_from`.
  - Итог — список координат, вроде `[(0, 0), (0, 1), (1, 1), ..., (14, 14)]`.

Путь получается угловатым, потому что двигаюсь по клеткам. 

### Вторая часть: Сглаживание пути с osqp

#### Общая идея
Путь от A* получился резким, как лестница, и я решил сделать его плавным, как кривую. Для этого я использовал квадратичное программирование (QP) с библиотекой `osqp`. QP — это когда мы минимизируем какую-то функцию, чтобы найти "лучшее" решение. Здесь я хотел:
- Убрать резкие углы (снизить кривизну).
- Не уходить слишком далеко от пути A*.

#### Как я это сделал?
1. **Разбил путь на X и Y:**
   - Взял координаты от A* (`path_astar`) и разделил их на `x_astar` (X-координаты) и `y_astar` (Y-координаты).
   - Например, если путь — `[(0, 0), (0, 1), (1, 1)]`, то `x_astar = [0, 0, 1]`, `y_astar = [0, 1, 1]`.

2. **Матрица D (вторые разности):**
   - Я создал матрицу `D`, чтобы посчитать кривизну. Она смотрит на "ускорение" между точками.
   - Формула: для трёх точек `x1, x2, x3` это `x1 - 2x2 + x3`. Если точки на прямой (например, `0, 1, 2`), то `D = 0`. Если угол резкий (например, `0, 1, 0`), то `D` большое.
   - В коде: `D = sparse.diags([1, -2, 1], [0, 1, 2], shape=(n-2, n))`, где `n` — число точек.
   - Это как "штраф" за углы: чем больше `D`, тем хуже.

3. **Матрица Q:**
   - Дальше я сделал `Q = D.T @ D` (отдельно для X и Y, объединено через `sparse.block_diag`).
   - `Q` отвечает за плавность. Если умножить координаты на `Q`, получится число, показывающее, насколько путь "дёргается". Я хочу это число уменьшить.

4. **Матрица A:**
   - Чтобы путь не ушёл далеко от A*, я добавил `A = sparse.eye(2 * n)` — это единичная матрица размером `2n x 2n` (для X и Y вместе).
   - Она говорит: "Новые точки должны быть близко к старым".

5. **Целевая функция:**
   - Я объединил всё в функцию `P = λ * Q + μ * A.T @ A`:
     - `λ = 1.0` — вес плавности. Чем больше, тем глаже линия.
     - `μ = 10.0` — вес привязки. Чем больше, тем ближе к A*.
   - Вектор `q = -μ * np.hstack([x_astar, y_astar])` тянет новые координаты к исходным.

6. **Решение с `osqp`:**
   - Я настроил задачу QP через `prob.setup(P, q, A, l, u)`:
     - `l` и `u` — это границы (`-∞` и `+∞`), то есть я не ограничивал точки жёстко.
     - `osqp` решает задачу и выдаёт `res.x` — новые координаты.
   - Разделил результат: `x_smooth = res.x[:n]`, `y_smooth = res.x[n:]`.

#### Что такое `osqp`?
- Это библиотека для QP, написанная на C, но с Python-интерфейсом. Она решает задачу вида:
  - Минимизировать: `½ xᵀ P x + qᵀ x`.
  - С ограничениями: `l ≤ A x ≤ u`.
- В моём случае `osqp` нашёл такие `x_smooth` и `y_smooth`, чтобы путь был плавным (за счёт `Q`) и не сильно отклонялся от A* (за счёт `A`).

#### Кривизна и как она уменьшается
- Кривизна — это когда путь резко поворачивает. Вторые разности (`D`) показывают, насколько точка выбивается из прямой.
- Например:
  - Путь `(0, 0), (0, 1), (1, 1)`: `x_astar = [0, 0, 1]`, `D = [0 - 2*0 + 1] = 1` — есть кривизна.
  - После сглаживания: `x_smooth = [0.1, 0.4, 0.9]`, `D = [0.1 - 0.8 + 0.9] = 0.2` — кривизна меньше.
- `osqp` минимизирует `xᵀ Q x`, что делает `D` ближе к нулю, то есть путь становится плавнее.

#### Баланс между плавностью и привязкой
- `λ` и `μ` — это как регуляторы:
  - Если `λ` больше, путь будет почти прямым, но может уйти от A*.
  - Если `μ` больше, путь будет ближе к A*, но угловатым.
  - Я выбрал `λ = 1.0` и `μ = 10.0`, чтобы привязка была сильнее, но плавность тоже заметна.

---

## Полный процесс

1. Создаю сетку: `grid = np.zeros((15, 15))`, добавляю препятствие `grid[5:10, 5:10] = 1`.
2. Нахожу путь A*: `path_astar = astar((0, 0), (14, 14), grid)`.
3. Сглаживаю путь с `osqp`, как описал выше.
4. Рисую график с `matplotlib`: сетка (чёрное), A* (красное), сглаженный путь (синее).

---
